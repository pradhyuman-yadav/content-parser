import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Import Guardrails and necessary validators
import guardrails as gd
from guardrails.hub import ProvenanceLLM
from pydantic import BaseModel, Field
import numpy as np

try:
    from sentence_transformers import SentenceTransformer
except ImportError:
    raise ImportError(
        "This script requires `sentence_transformers`. Install it with `pip install sentence_transformers`."
    )


# Load embedding model for validation
print("Loading embedding model...")
EMBEDDING_MODEL = SentenceTransformer("paraphrase-MiniLM-L6-v2")
print("Model loaded.")

def embed_function(sources: list[str]) -> np.array:
    return EMBEDDING_MODEL.encode(sources)

# --- 2. DEFINE OUTPUT STRUCTURE WITH PYDANTIC (CORRECTED) ---
# Pydantic models now accurately describe the target JSON structure.
# Key fields are no longer Optional to enforce extraction.

# class Location(BaseModel):
#     city: str = Field(description="The city of pickup or delivery.")
#     state: str = Field(description="The state's two-letter abbreviation.")
#     zip_code: str = Field(description="The zip code.")

# class Others(BaseModel):
#     weight_lbs: float = Field(description="The total weight in pounds.")
#     hazardous: bool = Field(description="Whether the shipment is hazardous.")

# class Shipment(BaseModel):
#     pickup: Location
#     delivery: Location
#     pickup_eta: Optional[str] = Field(description="The estimated date or time for pickup.")
#     delivery_eta: Optional[str] = Field(description="The estimated date or time for delivery.")
#     miles: Optional[float] = Field(description="The total distance in miles.")
#     others: Others

# class Rates(BaseModel):
#     base_rate: Optional[float] = Field(description="The base rate for the shipment.")

# # This is the corrected top-level model that matches the desired final output.
# class ExpectedOutput(BaseModel):
#     shipment: Shipment
#     rates: Optional[Rates]

class Location(BaseModel):
    city: Optional[str] = Field(None, description="The city of pickup or delivery.")
    state: Optional[str] = Field(None, description="The state's two-letter abbreviation.")
    zip_code: Optional[str] = Field(None, description="The zip code.")

class DimensionDetail(BaseModel):
    length: Optional[float] = Field(None, description="The length of the dimension.")
    width: Optional[float] = Field(None, description="The width of the dimension.")
    height: Optional[float] = Field(None, description="The height of the dimension.")

class Others(BaseModel):
    piece_count: Optional[int] = Field(None, description="The number of pieces or pallets.")
    stackable: Optional[str] = Field(None, description="Whether the freight is stackable.")
    hazardous: Optional[bool] = Field(None, description="Whether the shipment is hazardous.")
    weight_lbs: Optional[float] = Field(None, description="The total weight in pounds.")
    us_vehicle: Optional[str] = Field(None, description="The type of US vehicle required.")
    mx_vehicle: Optional[str] = Field(None, description="The type of MX vehicle required.")
    requirements: Optional[str] = Field(None, description="Any other special requirements.")

class Shipment(BaseModel):
    pickup: Optional[Location] = None
    delivery: Optional[Location] = None
    pickup_eta: Optional[str] = Field(None, description="The estimated date or time for pickup.")
    delivery_eta: Optional[str] = Field(None, description="The estimated date or time for delivery.")
    miles: Optional[float] = Field(None, description="The total distance in miles.")
    Hours: Optional[str] = Field(None, description="The total time taken or hours spent for the delivery.")
    dimensions: Optional[List[DimensionDetail]] = Field(None, description="A list of dimensions for each piece in the shipment.")
    others: Optional[Others] = None

class Rates(BaseModel):
    base_rate: Optional[float] = Field(None, description="The base rate for the shipment.")
    starboard_rates: Optional[List[str]] = Field(None, description="A list of supplementary rates from Starboard.")

# This is the corrected top-level model that matches the desired final output.
class ExpectedOutput(BaseModel):
    language: Optional[str] = Field(None, description="The primary language of the source text (e.g., English, Spanish).")
    shipment: Optional[Shipment] = None
    rates: Optional[Rates] = None

# --- 3. MAIN FUNCTION (CORRECTED VALIDATION LOGIC) ---

def process_text_with_validators(text_data: str) -> Dict[str, Any]:
    """
    Uses a two-step Guardrails process to first validate structure, then provenance.
    """

    prompt = f"""
    Based *only* on the text provided below, extract the information as a JSON object that strictly follows the required schema.
    If a value is not found in the text, use `null` only for optional fields.

    --- TEXT ---
    {text_data}
    --- END TEXT ---

    ${{gr.complete_json_suffix_v2}}
    """
    
    try:
        # --- Step 1: Validate JSON structure and schema ---
        # This guard now uses the corrected Pydantic model 'ExpectedOutput'.
        structure_guard = gd.Guard().for_pydantic(
            output_class=ExpectedOutput
        )

        print("Calling OpenAI for structured extraction...")
        response = structure_guard(
            model="gpt-4.1-2025-04-14", # Corrected model name
            messages=[
                {"role": "system", "content": "You are a data extraction expert that only outputs valid JSON objects based on the provided text and schema. You must fill in all non-optional fields."},
                {"role": "user", "content": prompt}
            ],
            temperature=0,
            max_tokens=500,
        )
        
        validated_structure = response.validated_output
        raw_output = response.raw_llm_output
        
        if not validated_structure:
            raise ValueError("Structural validation failed. The LLM output did not match the Pydantic schema.")

        # --- Step 2: Validate the provenance of the raw text ---
        # This guard checks if the original text from the AI is supported by the source document.
        provenance_guard = gd.Guard().use(
            ProvenanceLLM(
                llm_callable="gpt-4.1-2025-04-14",
                on_fail="fix", # Use exception for a clear failure
            )
        )

        print("Validating output against source text for provenance...")
        provenance_guard.validate(
            raw_output, # We validate the raw string output
            metadata={
                "sources": [text_data],
                "embed_function": embed_function,
            }
        )

        # --- Step 3: If both checks pass, return the result ---
        print("✅ SUCCESS: Both structure and provenance checks passed.")
        return validated_structure

    except Exception as e:
        print("❌ GUARDRAIL FAILED: The process did not pass validation.")
        print(f"   - Reason: {e}")
        return {"error": "Guardrails validation failed.", "details": str(e)}

# --- 4. EXAMPLE USAGE ---
if __name__ == "__main__":
    sample_text = """
    Subject: RATE REQUEST EXPEDITED: Oportunidad Cross Border / Pierburg Pump Mexico
 
Buen día,
 
Me apoyan con las siguientes cotizaciones de unidades dedicadas y expeditadas
 
Shipper : Pierburg Pump Technology México, S.A. de C.V. →
Cnee:  Falcon Manufacturing LLC
 
Ruta: Celaya, Gto. México → Columbus, IN, EE.UU.
Servicio: Dedicado Express Puerta a Puerta
Mercancía: Partes automotrices (sin mercancía peligrosa - No DGR)
 
1. Detalles de los Pallets
Tipo de Pallet   Dimensiones (cm)     	Peso Bruto (kg) Volumen (m³)
Tipo 1   130 x 120 x 100          	470.0	1.56
Tipo 2   130 x 120 x 100          	238.0	1.56
 
2. Frecuencia Estimada
Promedio diario: 3 pallets por día
 
Máximo por envío: hasta 10 pallets Tipo 1 y 15 pallets Tipo 2 cada 3 dias aprox
 
Vigencia estimada del proyecto: Diciembre 2025
 
Propuesta de Precios
 
Precio por camión expeditado cruce incluido
 
Otras Consideraciones
Certificaciones de cumplimiento disponibles bajo solicitud (CTPAT, OEA, etc.)
 
Saludos / Best Regards,

    """
    print("Starting high-efficiency data extraction process...")
    extracted_data = process_text_with_validators(sample_text)
    print("\n=============================================")
    print("✅ Extraction Complete. Final Validated JSON:")
    
    # Save the output to a timestamped JSON file
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"GP_extracted_data_{timestamp}.json"
    
    output_dict = extracted_data
    if hasattr(extracted_data, 'dict'):
        output_dict = extracted_data.dict()

    with open(filename, "w") as file:
        json.dump(output_dict, file, indent=2)
    
    print(f"Output saved to {filename}")

